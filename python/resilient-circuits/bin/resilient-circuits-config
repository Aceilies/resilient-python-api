#!/usr/bin/env python

""" Create or update a circuits config file """

import argparse
import logging
import os.path
import pkg_resources
import traceback
try:
    # For all python < 3.2
    import backports.configparser as configparser
except ImportError:
    import configparser
from builtins import input
from io import StringIO

LOG = logging.getLogger(__name__)
LOG.setLevel(logging.INFO)
LOG.addHandler(logging.StreamHandler())

def discover_required_config_sections():
    entry_points = pkg_resources.iter_entry_points('resilient.circuits.configsection')
    return [ep.load() for ep in entry_points]

def generate_default():
    """ return string containing entire default app.config """
    root = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
    base_config_fn = os.path.join(root, "data", "app.config.base")
    with open(base_config_fn, 'r') as base_config_file:
        base_config = base_config_file.read()
        additional_sections = [func() for func  in discover_required_config_sections()]
        LOG.debug("Found %d sections to generate", len(additional_sections))
        return "\n\n".join(([base_config,] + additional_sections))

def generate_or_update_config():
    """ Create or update config file based on installed components """
    parser = argparse.ArgumentParser()
    file_option_group = parser.add_mutually_exclusive_group(required=True)
    file_option_group.add_argument("-u", "--update",
                                   help="Add any missing sections required for installed components",
                                   action="store_true")
    file_option_group.add_argument("-c", "--create",
                                   help="Create new config file with all required sections",
                                   action="store_true")
    parser.add_argument("-v", "--verbose", help="Print debug output", action="store_true")
    parser.add_argument("filename", help="Config file to write to; e.g. 'app.config'")

    args = parser.parse_args()
    if args.verbose:
        LOG.setLevel(logging.DEBUG)

    usage_type = "CREATING" if args.create else "UPDATING"
    LOG.info("%s config file %s", usage_type, args.filename)

    config_filename = os.path.expandvars(os.path.expanduser(args.filename))
    file_exists = os.path.exists(config_filename)

    if file_exists:
        if args.create:
            choice = ""
            while choice not in ('y', 'n'):
                choice = input("%s exists. Do you want to overwrite? y/n: ")
            if choice == 'n':
                LOG.error("Config file creation cancelled.")
                return
    elif args.update:
        LOG.error("Config file does not exist. Update cancelled.")
        return

    if args.create:
        # Write out default file
        with open(config_filename, "w+", encoding="utf-8") as config_file:
            config_file.write(generate_default())
            LOG.info("Config generated. Please manually edit with your specific configuration values")

    else:
        # Update existing file
        config = configparser.ConfigParser()
        with open(config_filename, "r", encoding="utf-8") as config_file:
            first_byte = config_file.read(1)
            if first_byte != u'\ufeff':
                # Not a BOM, no need to skip first byte
                config_file.seek(0)
            config.read_file(config_file)
            existing_sections = config.sections()

        with open(config_filename, "a", encoding="utf-8") as config_file:
            for config_data in [func() for func  in discover_required_config_sections()]:
                required_config = configparser.ConfigParser()
                LOG.debug("Config Data String:\n%s", config_data)
                required_config.read_string(config_data)
                new_section = required_config.sections()[0]
                LOG.debug("Required Section: %s", new_section)
                if new_section not in existing_sections:
                    # Add the default data for this required section to the config file
                    LOG.info("Adding new section %s", new_section)
                    config_file.write(u"\n" + config_data)
                else:
                    LOG.debug("Section %s already present, not adding", new_section)

            LOG.info("Update finished. New sections may require manual edits with your specific configuration values")

if __name__ == "__main__":
    generate_or_update_config()
