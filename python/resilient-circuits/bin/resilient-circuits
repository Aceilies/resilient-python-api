#!/usr/bin/env python

""" Command line tool to manage and run resilient-circuits """

import argparse
import logging
import os.path
import pkg_resources
import re
import sys
import traceback
try:
    # For all python < 3.2
    import backports.configparser as configparser
except ImportError:
    import configparser

try:
    from builtins import input
except ImportError:
    # Python 2
    from __builtin__ import raw_input as input

from collections import defaultdict

LOG = logging.getLogger(__name__)
LOG.setLevel(logging.INFO)
LOG.addHandler(logging.StreamHandler())

def run(resilient_circuits_args):
    """Run resilient-circuits"""
    # Leave only the arguments for the run command
    from resilient_circuits import app # import here b/c it is slow
    sys.argv=sys.argv[0:1] + resilient_circuits_args
    app.run()

def list_installed():
    """print list of installed packages with their components"""
    LOG.debug("resilient-circuits.list")
    components = defaultdict(list)
    entry_points = [ep for ep in pkg_resources.iter_entry_points('resilient.circuits.components')]
    LOG.debug("Found %d installed components", len(entry_points))
    for ep in entry_points:
        components[ep.dist].append(ep.name)
    if not components:
        LOG.info("No resilient-circuits components are installed")
    LOG.info("The following packages and components are installed:")
    for dist, component_list in components.items():
        pkg = dist.project_name
        version = dist._version
        LOG.info("%s (%s) installed components:\n\t%s",
                 pkg,
                 version,
                 "\n\t".join(component_list))

def discover_required_config_sections():
    """return list of functions to call to generate sample config sections"""
    entry_points = pkg_resources.iter_entry_points('resilient.circuits.configsection')
    return [ep.load() for ep in entry_points]

def generate_default():
    """ return string containing entire default app.config """
    base_config_fn = pkg_resources.resource_filename("resilient_circuits", "data/app.config.base")
    with open(base_config_fn, 'r') as base_config_file:
        base_config = base_config_file.read()
        additional_sections = [func() for func  in discover_required_config_sections()]
        LOG.debug("Found %d sections to generate", len(additional_sections))
        return "\n\n".join(([base_config,] + additional_sections))

def generate_or_update_config(args):
    """ Create or update config file based on installed components """
    usage_type = "CREATING" if args.create else "UPDATING"
    LOG.info("%s config file %s", usage_type, args.filename)

    config_filename = os.path.expandvars(os.path.expanduser(args.filename))
    file_exists = os.path.exists(config_filename)

    if file_exists:
        if args.create:
            choice = ""
            while choice not in ('y', 'n'):
                choice = input("%s exists. Do you want to overwrite? y/n: ")
            if choice == 'n':
                LOG.error("Config file creation cancelled.")
                return
    elif args.update:
        LOG.error("Config file does not exist. Update cancelled.")
        return

    if args.create:
        # Write out default file
        with open(config_filename, "w+", encoding="utf-8") as config_file:
            config_file.write(generate_default())
            LOG.info("Config generated. Please manually edit with your specific configuration values")

    else:
        # Update existing file
        config = configparser.ConfigParser()
        with open(config_filename, "r", encoding="utf-8") as config_file:
            first_byte = config_file.read(1)
            if first_byte != u'\ufeff':
                # Not a BOM, no need to skip first byte
                config_file.seek(0)
            config.read_file(config_file)
            existing_sections = config.sections()

        with open(config_filename, "a", encoding="utf-8") as config_file:
            for config_data in [func() for func  in discover_required_config_sections()]:
                required_config = configparser.ConfigParser()
                LOG.debug("Config Data String:\n%s", config_data)
                required_config.read_string(config_data)
                new_section = required_config.sections()[0]
                LOG.debug("Required Section: %s", new_section)
                if new_section not in existing_sections:
                    # Add the default data for this required section to the config file
                    LOG.info("Adding new section %s", new_section)
                    config_file.write(u"\n" + config_data)
                else:
                    LOG.debug("Section %s already present, not adding", new_section)

            LOG.info("Update finished. New sections may require manual edits with your specific configuration values")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", help="Print debug output", action="store_true")

    subparsers = parser.add_subparsers(title="subcommands",
                                       help="one of these options must be provided",
                                       description="valid subcommands",
                                       dest="cmd")
    subparsers.required = True
    list_parser = subparsers.add_parser("list",
                                        help="List the installed Resilient Circuits components")
    run_parser = subparsers.add_parser("run",
                                       help="Run the Resilient Circuits application")
    config_parser = subparsers.add_parser("config",
                                          help="Create or update a basic configuration file")

    file_option_group = config_parser.add_mutually_exclusive_group(required=True)
    file_option_group.add_argument("-u", "--update",
                                   help="Add any missing sections required for installed components",
                                   action="store_true")
    file_option_group.add_argument("-c", "--create",
                                   help="Create new config file with all required sections",
                                   action="store_true")
    config_parser.add_argument("filename", help="Config file to write to; e.g. 'app.config'")

    run_parser.add_argument("resilient_circuits_args", help="Args to pass to app.run", nargs=argparse.REMAINDER)

    args, unknown_args = parser.parse_known_args()
    if args.verbose:
        LOG.setLevel(logging.DEBUG)

    if args.cmd != "run" and len(unknown_args) > 0:
        # Shouldn't have any unknown args for other commands, generate the proper errors
        args = parser.parse_args()

    if args.cmd == "config":
        generate_or_update_config(args)
    elif args.cmd == "run":
        run(unknown_args + args.resilient_circuits_args)
    elif args.cmd == "list":
        list_installed()

if __name__ == "__main__":
    LOG.debug("CALLING MAIN")
    main()
